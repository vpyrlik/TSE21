<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Time Series Econometrics, Spring 2021</title>
    <meta charset="utf-8" />
    <meta name="author" content="Vladimir Pyrlik" />
    <meta name="date" content="2021-02-05" />
    <link rel="stylesheet" href="libs/main.css" type="text/css" />
    <link rel="stylesheet" href="libs/fonts.css" type="text/css" />
    <link rel="stylesheet" href="libs/animate.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Time Series Econometrics, Spring 2021
## Lecture 2. Stationarity (continued)
### Vladimir Pyrlik
### February 5, 2021

---

class: hands, middle, animated, fadeIn

#Stretching

---
class: hands, animated, flipInX     

.gb[Example 1] **The Big Mac Index**: *USD/RUR* PPP exchange rate

![](stuff/q3.png)

.bb[?] **Stationary?** *Defenitely not / Not likely / Might be?*

---
class: hands, animated, flipInY

.gb[Example 2] **Gini Index**: Russian annual income inequality

![](stuff/q2.png)

.bb[?] **Stationary?** *Defenitely not / Not likely / Might be?*

---
class: hands, animated, flipInX

.gb[Example 3] **Population**: Russian age 10 males, annual change

![](stuff/q1.png)

.bb[?] **Stationary?** *Defenitely not / Not likely / Might be?*

---
class: section, animated, fadeIn

#Quick Recall

### of the previous lecture

---
class: animated, fadeIn

#Quick Recall

- TS are a lot different from RS

--

- Many traditional tools are not applicable to TS right away, ...

--

- but there are applicable versions for S&amp;ETS

--

- Stationarity is a crucial concept in TS

--

- Types of stationarity: strict &amp; weak

--

- Strict is only theoretical, and weak can be observed in the data

--

- Essential judgment &amp; visual analysis are important tools, ...

--

- .RUred[but often *formal testing* is required, too.]

---
class: section, animated, fadeIn

#Stationarity: Formal Testing

---
class: animated, fadeIn

#General Formal Testing: a brief recap

.gb[e.g.] Consider a simple **one-sample two-sided *z*-test**. Given some data `\(\{x_i\}_{i=1}^N\)`, with `\(x_i\sim\text{i.i.d.}\)`, test the null `\(H_o=\{\mathbb{E}x=\mu_o\}\)` versus `\(H_a=\{\mathbb{E}x\neq\mu_o\}\)`.

--

.bb[?] What are **hypotheses**?

--

.bb[?] What is a **statistical test**? .rmk[aka a *conventional statistical criterion*]

--

.bb[?] What is a **test statistics**? .rmk[why is this test called "*z*"?]

--

.bb[?] What is a **critical value**?

--

.bb[?] What is a **P-value**?

--

.bb[?] What is the general **scheme of a test application**?

---
class: animated, fadeIn

#Formal Testing for a TS Stationarity

There are several approaches. Two are most commonly used.

--

### 1. Augmented Dickey - Fuller (ADF) Test

- `\(H_o = \{\text{unit root}\}\)` **vs** `\(H_a=\{\text{TS is stationary}\}\)`.
.right[.rmk["*unit root*" is a type of non-stationarty (we'll deal with it next time)]]

--

- under true null the **test statistics has a non-standard distribution**, critical values and P-values can only be tabulated

--

.rb[!] ADF tends to **under-reject the FALSE null**&lt;/br&gt;when a truly stationary TS is close to being non-stationary

---
class: animated, fadeIn

#Formal Testing for a TS Stationarity

There are several approaches. Two are most commonly used.

### 2. Kwiatkowski - Phillips - Schmidt - Shin (KPSS) Test

- `\(H_o=\{\text{TS is stationary}\}\)` **vs** `\(H_a=\{\text{TS is non-stationary}\}\)`.
.right[.rmk[.rb[!] compare the hypotheses with the ones of ADF above]]

--

- critical values and P-values can only be tabulated&lt;/br&gt;

--

.rb[!] often used to support or double-check the results of ADF test

---
class: center, animated, fadeIn

##Recall [.gb[Example 3] from the previous lecture](https://vpyrlik.github.io/tse19lec01/slides.html#31)

.pull-left[

![](stuff/stat03small.png)&lt;/br&gt;&lt;/br&gt;

 
| Test          | P-value        |
|:--------------|:--------------:|
| ADF           | 0.068          |
| KPSS          | &gt; 0.1          |

]

--

.pull-right[&lt;/br&gt;

.bb[?] What are the first steps to test stationarity?&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;

.bb[?] How do we interpret the tests results?

]

---
class: center, animated,  flipInY

##Recall [.gb[Example 2] from the previous lecture](https://vpyrlik.github.io/tse19lec01/slides.html#30)

.pull-left[

![](stuff/stat02.png)&lt;/br&gt;&lt;/br&gt;

 
| Test          | P-value        |
|:--------------|:---------------|
| ADF           | &lt; 0.01         |
| KPSS          | &gt; 0.1          |

]

.pull-right[&lt;/br&gt;

.bb[?] What are the first steps to test stationarity?&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;

.bb[?] How do we interpret the tests results?

]

---
class: center, animated,  flipInX

##Recall .gb[Example 2] from earlier today

.pull-left[

![](stuff/q2title.png)&lt;/br&gt;&lt;/br&gt;

 
| Test          | P-value        |
|:--------------|:---------------|
| ADF           | 0.90         |
| KPSS          | &gt; 0.1          |

]

.pull-right[&lt;/br&gt;

.bb[?] What are the first steps to test stationarity?&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;

.bb[?] How do we interpret the tests results?

]

---
class: animated, fadeIn

#Wrap-up

- There are many formal tests of stationarity

- The two most commonly used test are: .bb[?] &amp; .bb[?] &lt;/br&gt;&lt;/br&gt;

--

- The main difference between the two is .bb[?] &lt;/br&gt;&lt;/br&gt;

--

- ADF test has the tendency to .bb[?] &lt;/br&gt;&lt;/br&gt;

--

- KPSS test is often used to .bb[?]

---
class: animated, fadeIn

#What's next?

Thus, many important economic series are non-stationary. 

.bb[?] So what? &lt;/br&gt;&lt;/br&gt;

--

.rb[!] Modeling *often* requires stationarity. &lt;/br&gt;&lt;/br&gt;

--

### Next in the course

- Stationary transformations .rmk[(now)]

--

- Linear modeling &amp; prediction .rmk[(weeks 3-4)]

---
class: section, animated, fadeIn

#Stationary Transformations

###a way to deal with non-sattionary TS

---
class: center, animated, fadeIn

#.left[Stationary Transformations]

.rb[!] A lot of crucial economic TS are **essentially non-stationary**&lt;/br&gt;

--

.bb[?] Have we seen earlier today .rmk[(or even earlier)]&lt;/br&gt; an example of a **stationary transformation**?

--

Recall .gb[Example 3] from the previous lecture again

.pull-left[

![](stuff/stat03small.png)

]

--

.pull-right[

.left[&lt;/br&gt;.bb[?] What is the transformation here?]

.left[.bb[?] How does the initial import series look?]

]

---
class: animated, fadeIn

#Stationary Transformations

Non-stationary TS are transformed into stationary ones for modeling. &lt;/br&gt;

--

.rb[!] Type of transformation depends on type of non-stationarity. &lt;/br&gt;

--

- Most transformations are to handle *trends in mean prior to modeling*. &lt;/br&gt; 

--

- *Structural breaks* &amp; *heteroskedasticity* are dealt with *inside the models*.

---
class: animated, fadeIn

#De-trending Transformations

There are many types of transformations. &lt;/br&gt;&lt;/br&gt;

Usually, same TS can be transformed into a stationary one&lt;/br&gt;via several different transformations.&lt;/br&gt;&lt;/br&gt;

--

.rb[!] **Essential meaning** of a transformation is crucial.

---
class: animated, fadeIn

#De-trending Transformations

.gb[*e.g.*] Compare **percentage changes** &amp; **deviations from a trend**&lt;/br&gt;&lt;/br&gt;

--

.rb[!] percentage change is one-period change in the value

- good for **short-run** policy effects evaluation or prediction &lt;/br&gt;&lt;/br&gt;

--

.rb[!] trends show **long-run** tendencies

- *might be used* in LR prediction or causality analysis,&lt;/br&gt;.rmk[but actually, these are almost never done in practice anymore.&lt;/br&gt;Why not? Revisit this in a practice session]

---
class: animated, fadeIn

#De-trending Transformations
###Main types of stationary transformations

- **difference transformations** &amp; log-differences &lt;/br&gt;&lt;/br&gt;

- growth rates &amp; percentage change &lt;/br&gt;&lt;/br&gt;&lt;/br&gt;

--

.rb[!] They are all based on **difference transformations**.

---
class: animated, fadeIn

#Difference Transformations

.gb[Example 1] Carbon Dioxide Emmissions - Morocco (annual, Mt)

![](stuff/ex1.png)

---
class: center, animated, fadeIn

#.left[Difference Transformations]&lt;/br&gt;

Givent a TS process `\(\{X_t\}_{t=-\infty}^{+\infty}\)`, the **first difference** of the TS is

`$$\Delta X_t\equiv X_t-X_{t-1}$$` &lt;/br&gt;&lt;/br&gt;

--

The **difference of order *p*** .rmk[(*aka* the *p*-th difference)] is

`$$\Delta^p X_t\equiv\Delta\left(\Delta^{p-1}X_t\right),\;p&gt;1$$`

---
class: animated, fadeIn

#Difference Transformations: interpretation

.gb[Example 2] Some simulated data

.center_img[![](stuff/diffs_ex1.png)]

---
class: tps, animated, flipInX

##Think - Share &lt;/br&gt;&lt;/br&gt;

.bb[?]

###Say, the 1st diffs are positive on average (mean &gt; 0).

###Does it .RUred[guarantee] that the levels grew over the period?

---
class: animated, fadeIn

#Difference Transformations: interpretation

.gb[Example 2] Some simulated data

.center_img[![](stuff/diffs_ex1.png)]

--

.center_img[![](stuff/diffs_ex2.png)]

--

.center_img[![](stuff/diffs_ex3.png)]

--

.center_img[![](stuff/diffs_ex4.png)]

--

.center_img[![](stuff/diffs_ex5.png)]

--

.center_img[![](stuff/diffs_ex6.png)]

--

.center_img[![](stuff/diffs_ex7.png)]

--

.center_img[![](stuff/diffs_ex8.png)]

--

.center_img[![](stuff/diffs_ex9.png)]

--

.center_img[![](stuff/diffs_ex10.png)]

--

.center_img[![](stuff/diffs_ex11.png)]

--

.center_img[![](stuff/diffs_ex12.png)]

--

.center_img[![](stuff/diffs_ex13.png)]

--

.center_img[![](stuff/diffs_ex14.png)]

---
class: animated, fadeIn

#Difference Transformations

- diffs preserve the same units

- the 1st diffs are easily interpritable&lt;/br&gt;&lt;/br&gt;

--

.rb[!] often the 1st diffs are not enough to "kill" the non-stationarity

.rb[!] higher orders of diffs are harder to interpret&lt;/br&gt;&lt;/br&gt;

--

- 2nd order diffs are sometimes used

- 3+ orders are almost never used in practice

---
class: center, animated, fadeIn

#.left[Other Transformations]

###The percentage change .rmk[aka] growth rate

The **1-period percentage cahnge** .rmk[aka] **1-period growth rate** is

`$$\rho_t=\frac{\Delta X_t}{X_{t-1}}=\frac{X_t}{X_{t-1}}-1$$`

--

.left[

.rb[!] shows 1-period **scale-free change**

.rb[!] often **kills NS better** than the diffs

]

--

.left[

.rb[!] unlike the diffs, **not additive**

]

---
class: center, animated, fadeIn

#.left[Other Transformations]

###Log-differences .rmk[aka] log-returns .rmk[aka] log growth rate

--

Givent a TS process `\(\{X_t\}_{t=-\infty}^{+\infty}\)`, the **log-difference** of the TS is

`$$\Delta \log X_t\equiv \log X_t-\log X_{t-1}=\log\left(\frac{X_t}{X_{t-1}}\right)$$`

--

.bb[?] Why "*log growth rate*"?

--

`$$\log\left(\frac{X_t}{X_{t-1}}\right)=\log\left(\frac{X_t-X_{t-1}}{X_{t-1}}+1\right)\approx\frac{X_t-X_{t-1}}{X_{t-1}}$$`
--

.rb[!] When `\(\rho_t\)` is "*small enough*",&lt;/br&gt;growth rate and log-diffs are "*almost the same*"

---
class: center, animated, flipInX

##Log-diffs **vs** growth rate *numerically*
![](stuff/logdiffs_vs_growthr.png)

---
class: animated, fadeIn

#Log-diffs: interpretation

.gb[Example 3] Some simulated log-diffs

.center_img[![](stuff/logdiffs_ex1.png)]

---
class: hands, animated, flipInX

&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;.bb[?]&lt;/br&gt;Say, The log-diffs are positive on average (mean &gt; 0)&lt;/br&gt;Does it .RUred[guarantee] that the levels grew over the period?&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;


.bb[?]&lt;/br&gt;How do we interpret the mean of log-diffs over some period?

---
class: animated, fadeIn

#Difference Transformations: interpretation

.gb[Example 3] Some simulated log-diffs

.center_img[![](stuff/logdiffs_ex1.png)]

--

.center_img[![](stuff/logdiffs_ex2.png)]

--

.center_img[![](stuff/logdiffs_ex3.png)]

--

.center_img[![](stuff/logdiffs_ex4.png)]

--

.center_img[![](stuff/logdiffs_ex5.png)]

--

.center_img[![](stuff/logdiffs_ex6.png)]

--

.center_img[![](stuff/logdiffs_ex7.png)]

--

.center_img[![](stuff/logdiffs_ex8.png)]

--

.center_img[![](stuff/logdiffs_ex9.png)]

--

.center_img[![](stuff/logdiffs_ex10.png)]

--

.center_img[![](stuff/logdiffs_ex11.png)]

--

.center_img[![](stuff/logdiffs_ex12.png)]

---
class: animated, fadeIn

#% Change &amp; Log-differences: interpretation

- both often kill NS better when 1st diffs are not enough&lt;/br&gt;&lt;/br&gt;

--

- both show 1-period change&lt;/br&gt;&lt;/br&gt;

--

- very close technically &amp; essentially&lt;/br&gt;&lt;/br&gt;

--

- unlike % change, log-diffs are additive&lt;/br&gt;&lt;/br&gt;

--

.rb[!] often .rmk[(not always!)] log-diffs are preferred to % change to kill NS

---
class: center, animated, rubberBand

###for this class we have a self-directed
#Take-home Wrap-up&lt;/br&gt;

###go to **wooclap.com/TSWRAPUP** and complete the quizz
.rmk[it's gonna help you a lot the next week!]&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;

#Thank you!
### See you next time
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"countIncrementalSlides": false,
"highlightLines": true,
"ratio": "8:5"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
